#!/bin/bash
#
# Wicked helper script to bring infiniband devices up or down
#
# wicked-infiniband [start|stop] ifname
#
# Environment:
#  IPOIB_MODE
#	connected, datagram, or empty
#  IPOIB_UMCAST
#	0, 1, or empty
#
# Based on the ifup-infiniband script in SLES, which is:
#
# Copyright (c) 2007 SUSE LINUX Products GmbH, Germany.
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA 02111-1307 USA
#
# Authors: Marius Tomaschewski <mt@suse.de>
#          Moni Shoua <monis@voltaire.com>
#

ACTION=$1
INTERFACE=$2

######################################################################
# Helper functions
create_ib_child_iface() {
	# e.g. ib0.8001
	IBIFACE=$1

	IBPARENT=${IBIFACE%%\.*}
	IBCHILD=${IBIFACE#*\.}

	# Check if the device name is ib0, ib1 etc.
	if [ "${IBPARENT:0:2}" != "ib" ] ; then
		return 1
	fi
	# Check if the devices does not contain a "."
	if [ "${IBCHILD}" == "${IBIFACE}" ] ; then
		return  1
	fi
	if [ -d "/sys/class/net/${IBPARENT}.${IBCHILD}" ] ; then
		return 0
	fi
	if [ -e "/sys/class/net/${IBPARENT}/create_child" ] ; then
		echo "0x${IBCHILD}" > "/sys/class/net/${IBPARENT}/create_child"
		ip link show dev "${IBPARENT}.${IBCHILD}" &>/dev/null
	else
		return 1
	fi
}
delete_ib_child_iface() {
	# e.g. ib0.8001
	IBIFACE=$1

	IBPARENT=${IBIFACE%%\.*}
	IBCHILD=${IBIFACE#*\.}

	# Check if the device name is ib0, ib1 etc.
	if [ "${IBPARENT:0:2}" != "ib" ] ; then
		return 1
	fi
	# Check if the devices does not contain a "."
	if [ "${IBCHILD}" == "${IBIFACE}" ] ; then
		return 1
	fi
	if [ ! -d "/sys/class/net/${IBPARENT}.${IBCHILD}" ] ; then
		return 0
	fi
	if [ -e "/sys/class/net/${IBPARENT}/delete_child" ] ; then
		echo "0x${IBCHILD}" > "/sys/class/net/${IBPARENT}/delete_child"
		[ -d "/sys/class/net/${IBPARENT}.${IBCHILD}" ] || return 0
	else
		return 1
	fi
}


######################################################################
# The fun starts here
case $ACTION in
start)
	# verify values of interface parameters
	case $IPOIB_MODE in
	connected|datagram|"") ;;
	*)
		echo "illegal value for IPOIB_MODE: $IPOIB_MODE" >&2
		exit 2
	;;
	esac

	case $IPOIB_UMCAST in
	0|1|"") ;;
	*)
		echo "illegal value for IPOIB_UMCAST: $IPOIB_UMCAST" >&2
		exit 2
	;;
	esac

	# create ib-child interfaces, report non-existing parents
	case "$INTERFACE" in
	ib*.*)	# ib child interface
		create_ib_child_iface "$INTERFACE" || exit 1
	;;
	*)	# ib parent interface
		# If we get here, the interface doesn't exit, and we don't
		# know how to create it.
		exit 1
	;;
	esac

	# set interface parameters
	if test -n "$IPOIB_MODE" ; then
		echo "$IPOIB_MODE"   > "/sys/class/net/$INTERFACE/mode"
	fi
	if test -n "$IPOIB_UMCAST" ; then
		echo "$IPOIB_UMCAST" > "/sys/class/net/$INTERFACE/umcast"
	fi
;;
down)
	case "$INTERFACE" in
	ib*.*)	# ib child interface
		delete_ib_child_iface "$INTERFACE" || RETVAL=$R_ERROR
	;;
	*)	# ib parent interface
		:
	;;
	esac
;;
esac

exit 0
